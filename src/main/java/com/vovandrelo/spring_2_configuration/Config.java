package com.vovandrelo.spring_2_configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// <============================================= Конфигурационный класс ==============================================>

// Для создания Code-конфигурации используется аннотация @Configuration, она указывает на то, что класс является
// источником определения bean-ов. Аннотация @Configuration говорит Spring, что класс может содержать методы,
// аннотированные @Bean, и каждый такой метод будет создавать и возвращать объект (бин), который должен быть
// зарегистрирован в контексте приложения.
//
// @Configuration является специализированной формой @Component, что означает, что конфигурационные классы
// автоматически обнаруживаются при сканировании путей. Если в проекте нет аннотации @ComponentScan, то Spring
// не будет автоматически сканировать пакеты на наличие компонентов, включая классы с аннотацией @Configuration.
// В таком случае, чтобы Spring узнал о ваших конфигурационных классах, вам нужно будет явно указать их при создании
// контекста приложения.

// Проксирование
// Когда Spring видит @Configuration, он может создать прокси-объект для этого класса, чтобы обеспечить правильное
// поведение семантики @Bean. Это означает, что при вызове метода, аннотированного @Bean, внутри конфигурационного
// класса, Spring обеспечит, что возвращается один и тот же экземпляр bean-а (singleton scope по умолчанию), а не
// создаст  новый экземпляр.

// Внедрение зависимостей
// В конфигурационных классах можно использовать внедрение зависимостей через конструкторы, поля или сеттеры, как и в
// любом другом компоненте Spring.

@Configuration
public class Config {
    // <============================================== Аннотация @Bean ================================================>
    //
    // Аннотация @Bean применяется к методам в классах, аннотированных с @Configuration, чтобы указать, что
    // возвращаемый объект метода должен быть зарегистрирован как бин (bean) в контексте Spring.
    //
    // Основные параметры:
    // - name: Определяет имена bean-ов, которые будут созданы с помощью этого метода. Если не указано, то в качестве
    //   имени bean-а используется имя метода. Можно указать несколько имен, если нужно зарегистрировать бин с
    //   несколькими именами.
    // - initMethod: Указывает имя метода, который будет вызван сразу после создания bean-а и инъекции всех
    //   зависимостей, но до того, как бин будет использован в приложении. Это может быть использовано для
    //   инициализации bean-а.
    // - destroyMethod: Указывает имя метода, который будет вызван перед уничтожением bean-а. Этот метод может быть
    //   использован для освобождения ресурсов, занятых бином.

    // Создание bean-а с именем somePet и типом Pet:
    @Bean
    public Pet somePet() {
        return new Pet("Барсик");
    }

    // Создание bean-а с последующим внедрением зависимостей, причём внедрять зависимости можно как с помощью
    // конструктора, так и с помощью set-тера:
    @Bean
    public Person somePerson() {
        return new Person("Анатолий", somePet());
    }

    // Методы somePet и somePerson будут вызваны контейнером Spring при старте приложения, и возвращаемые ими объекты
    // будут зарегистрированы как bean-ы, следовательно, их можно будет внедрить в другие компоненты приложения.

    // <============================================== Аннотация @Lazy ================================================>

    // Аннотация @Lazy используется для создания лениво загружаемых bean-ов. Т.е bean будет инициализирован только
    // тогда, когда он впервые будет запрошен из контекста приложения, а не при старте приложения. Эта аннотация может
    // быть применена как к определению компонента с помощью аннотации @Component, так и к методу в конфигурационном
    // классе, аннотированном @Configuration.
}
