package com.vovandrelo.spring_5_bean_life_cycle;

import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

// <============================================ ЖИЗНЕННЫЙ ЦИКЛ BEAN-А =============================================> \\

// Жизненный цикл bean-а:
// Этап №1 - Предоставление метаданных:
// Разработчики предоставляют приложению конфигурацию bean-ов в виде xml-конфигураций, java-конфигураций или
// java-аннотаций.
//
// Этап №2 - Создание BeanDefinitionReader:
// После запуска приложения для каждого типа предоставленной конфигурации создаётся соответствующая реализация
// интерфейса BeanDefinitionReader.
//
// Этап №3 - Чтение метаданных:
// Каждый из экземпляров BeanDefinitionReader обрабатывает соответствующую конфигурацию и на её основе создаёт
// BeanDefinition. BeanDefinition представляет собой метаданные, которые описывают создание и настройку конкретного
// bean-а.
//
// Этап №4 - Регистрация BeanDefinition:
// После создания BeanDefinition происходит его регистрация в BeanFactory с помощью интерфейса BeanDefinitionRegistry.
// Регистрация представляет собой создание пары, где ключом является ID-bean-а, а значением - его BeanDefinition, и
// добавление её в хранилище (представленное коллекцией Map) внутри BeanFactory.
// ! На данном этапе происходит размещение информации о конфигурации bean-ов в BeanFactory, а не их создание !
//
// Этап №5 - Обработка BeanDefinition с помощью BeanFactoryPostProcessor:
// BeanFactoryPostProcessor - это интерфейс, который позволяет разработчикам вносить изменения в конфигурацию bean-ов,
// до того как будет начат процесс их создания. После этапа регистрации, Spring выполняет поиск всех реализаций
// интерфейса BeanFactoryPostProcessor и запускает его единственный метод postProcessBeanFactory, внутри которого
// можно получить доступ ко всем BeanDefinition (через ConfigurableListableBeanFactory) и выполнить их модификацию
// (изменение свойств BeanDefinition, добавление или удаление определений bean-ов и т.д.).
// Важный момент заключается в том, что BeanFactoryPostProcessor вызывается до того, как любой бин будет создан, что
// позволяет вносить изменения в конфигурацию bean-ов, не влияя на уже созданные экземпляры.
//
// Этап №6 - Создание Bean-а.
//
// Этап №7 - Инициализация Bean-а:
// Перед началом инициализации bean-а Spring автоматически выполняет поиск реализации интерфейса BeanPostProcessor и
// применяет его методы ко всем bean-ам в контейнере:
// - Метод postProcessBeforeInitialization: вызывается непосредственно после создания bean-а и заполнения всех его
//   свойств, но до вызова методов инициализации, таких как initMethod или @PostConstruct.
// - Метод postProcessAfterInitialization: вызывается после того, как bean был инициализирован, то есть после вызова
//   методов инициализации.
//
// Этап №8 - Bean готов к использованию:
// Все созданные bean-ы хранятся внутри BeanFactory и могут быть предоставлены по первому требованию приложения.
// В том случае, если запрашиваемый bean имеет scope-prototype, то он сначала создаётся на основании BeanDefinition,
// и только потом возвращается в приложение.
//
// Этап №9 - Уничтожение Bean-а:
// При завершении работы приложения или при явном закрытии контекста приложения, контейнер Spring начинает процесс
// уничтожения bean-ов. Если для Bean определен метод уничтожения, он будет вызван. После вызова метода уничтожения,
// Bean будет уничтожен, и память, занимаемая им, будет возвращена системе.

// <===================================== МЕТОДЫ PRE-DESTROY и POST-CONSTRUCT ======================================> \\

// Аннотация @PostConstruct используется для указания метода, который должен быть выполнен после того, как экземпляр
// bean-а был создан и все зависимости были внедрены (т.е. после инициализации).
//
// Аннотация @PreDestroy применяется для указания метода, который должен быть вызван перед тем, как бин будет
// уничтожен.

@Component
public class Animal {
    public void sayHello() {
        System.out.println("Привет! Я животное");
    }

    @PostConstruct
    public void init() {
        System.out.println("The init method was started");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("The destroy method has been completed");
    }

    // Аннотации @PostConstruct и @PreDestroy являются частью Java EE, которая устарела в Java 9. Следовательно, данные
    // аннотации аналогично считаются устаревшими (Deprecated). А С Java 11 вообще были удалены, поэтому мы должны
    // добавить дополнительную зависимость для использования этих аннотаций.
}
