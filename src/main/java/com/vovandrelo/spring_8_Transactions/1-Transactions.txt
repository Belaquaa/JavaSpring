<============================================== Аннотация @Transactional ==============================================>

Аннотация @Transactional в Spring Framework представляет собой механизм декларативного управления транзакциями. Она
позволяет разработчикам определить границы транзакции на уровне методов или классов без необходимости работы с API
транзакций напрямую. Это упрощает разработку, так как отвлекает разработчика от ручного управления транзакциями.

Когда метод класса аннотирован @Transactional, Spring создает прокси вокруг этого объекта. При вызове аннотированного
метода прокси управляет процессом создания, коммита или отката транзакции.

Аннотация @Transactional может быть настроена с помощью различных атрибутов, таких как:
- propagation: определяет как транзакция распространяется.
- isolation: определяет уровень изоляции транзакции, который может помочь предотвратить проблемы, такие как "грязное
  чтение", "неповторяющееся чтение" и "фантомное чтение".
- readOnly: указывает, что транзакция должна быть только для чтения, что может помочь оптимизировать некоторые операции
  на уровне базы данных.
- timeout: определяет время в секундах, в течение которого транзакция должна быть завершена.
- rollbackFor и noRollbackFor: определяют классы исключений, которые должны приводить к откату или не приводить к
  откату транзакции соответственно.

<========================================== Компонент TransactionInterceptor ==========================================>

TransactionInterceptor - это класс из SpringFramework-а, который содержит в себе всю основную логику управления
транзакциями. В контексте AOP он является Around-Advice-ом, т.е. перехватывает все вызовы @Transactional-методов
и интегрирует в них функционал управления транзакциями.

* Этот компонент представлен классом, который реализует интерфейсы MethodInterceptor и AfterReturningAdvice из
  библиотеки Spring AOP, а также ThrowsAdvice из AspectJ. Это позволяет ему встраиваться в вызовы методов и
  предоставлять транзакционное поведение.

TransactionManager - это интерфейс, который предоставляет конкретные методы для управляет транзакциями на уровне
ресурсов (например, соединений с базой данных).

То есть TransactionInterceptor - это некая абстрактная обёртка над TransactionManager.

<======================================= Аннотация @EnableTransactionManagement =======================================>

Аннотация @EnableTransactionManagement используется для включения поддержки декларативного управления транзакциями в
приложении. Это означает, что вы можете управлять транзакциями с помощью аннотаций, таких как @Transactional, без
необходимости настраивать их вручную.

В контексте AOP, при использовании @EnableTransactionManagement, создаётся Advice, представленный Spring-компонентом
TransactionInterceptor, который перехватывает вызовы @Transactional-методов и отвечает за следующие аспекты управления
транзакциями:
  1. Создание новой транзакции, если это необходимо (если текущий метод не выполняется в контексте существующей
     транзакции).
  2. Присоединение к существующей транзакции, если метод выполняется в рамках транзакционного контекста.
  3. Управление транзакционными свойствами, такими как изоляция, распространение, тайм-аут и только для чтения.
  4. Обработка исключений и откат транзакции в случае возникновения определенных типов исключений.
  5. Подтверждение транзакции, если метод выполнен успешно.

В Spring-Boot-приложениях управление транзакциями будет включено по умолчанию.

<============================================== Вложенные @Transactional ==============================================>

Когда вы имеете дело с вложенными методами, важно понимать, как работает распространение транзакций (propagation
behavior). Поведение распространения определяется атрибутом propagation аннотации @Transactional. Ниже приведены
наиболее часто используемые типы распространения:

1. REQUIRED (по умолчанию): Если существует текущая транзакция, метод выполняется в этой транзакции. Если нет,
   создается новая транзакция.
2. REQUIRES_NEW: Всегда создается новая транзакция, и если существует текущая транзакция, она приостанавливается
   на время выполнения метода.
3. SUPPORTS: Если существует текущая транзакция, метод выполняется в этой транзакции. Если нет, метод выполняется
   без транзакции.
4. NOT_SUPPORTED: Метод выполняется без транзакции, и если существует текущая транзакция, она приостанавливается на
   время выполнения метода.
5. MANDATORY: Метод должен выполняться в контексте уже существующей транзакции, иначе будет выброшено исключение.
6. NEVER: Метод не должен выполняться в контексте транзакции, иначе будет выброшено исключение.

Важно помнить, что аннотация @Transactional работает только когда вызов метода идет через прокси-объект Spring. Если
метод, помеченный @Transactional, вызывается внутри того же класса, где он определен, аннотация @Transactional не будет
работать, поскольку вызов происходит напрямую, минуя прокси.

<============================================= @Transactional и исключения ============================================>

При получении исключения внутри метода, помеченного аннотацией @Transactional, поведение транзакции зависит от типа
исключения и конфигурации аннотации.

По умолчанию, если во время выполнения транзакционного метода возникает непроверяемое исключение (unchecked exception),
например, RuntimeException или его наследники, Spring отмечает текущую транзакцию как откатываемую (rollback-only).

Если же возникает проверяемое исключение (checked exception), например, Exception или его наследники, кроме
RuntimeException, транзакция по умолчанию не откатывается, и изменения в базе данных сохраняются.

Однако поведение при получении исключений можно настроить с помощью атрибутов rollbackFor и noRollbackFor, которые
позволяют указать, для каких исключений следует выполнять откат транзакции, а для каких — нет.

<=========================================== Алгоритм работы @Transactional ===========================================>

Алгоритм работы метода с аннотацией @Transactional:
 - Когда вызывается метод, который был настроен для управления транзакциями помощью аннотаций @Transactional,
   TransactionInterceptor перехватывает этот вызов.
 - TransactionInterceptor проверяет, нужно ли начать новую транзакцию, присоединиться к существующей или выполнить
   другие действия, основанные на атрибутах аннотации @Transactional.
    - Если необходимо создать новую транзакцию: TransactionInterceptor с помощью TransactionManager, обращается к
      EntityManagerFactory для создания нового EntityManager и присоединения его к текущему потоку приложения. Новая
      транзакция будет ассоциирована с новым EntityManager.
    - Если необходимо использовать уже существующую транзакцию: TransactionInterceptor с помощью TransactionManager
      будет управлять уже существующем в данном потоке EntityManager-ом.
 - После установки или присоединения к транзакции, TransactionInterceptor передает управление целевому методу. Метод
   выполняется стандартно, но теперь в контексте транзакции.
 - После выполнения бизнес-логики, TransactionInterceptor снова обращается к TransactionManager для коммита или отката
   транзакции в зависимости от того, произошло ли исключение во время выполнения метода и от правил транзакции.
 - После завершения транзакции EntityManager закрывается или возвращается в pool.

 <===================================== Связывание @Transactional и EntityManager ======================================>

 EntityManager является частью спецификации JPA и предоставляет API для выполнения операций с базой данных, таких как
 поиск, вставка, обновление и удаление записей.

 Когда приложение запрашивает EntityManager внутри слоя DAO или репозитория, Spring предоставляет EntityManager-Proxy,
 который делегирует вызовы к реальному EntityManager, связанному с текущей транзакцией. Этот прокси обеспечивает
 правильное управление транзакциями и связывание EntityManager с текущим потоком исполнения.